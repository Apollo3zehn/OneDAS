using System;
using System.Diagnostics.Contracts;
using System.Runtime.InteropServices;

namespace OneDas.Infrastructure
{
    /// <summary>
    /// Represents an infrastructure to buffer data.
    /// </summary>
    public abstract class DataStorageBase : IDisposable
    {
        #region "Fields"

        protected GCHandle _gcHandle1;
        protected GCHandle _gcHandle2;
        protected GCHandle _gcHandle_Status1;
        protected GCHandle _gcHandle_Status2;

        #endregion

        #region "Constructors"

        /// <summary>
        /// Creates a new <see cref="DataStorageBase"/> instance.
        /// </summary>
        /// <param name="HdfVariable">The associated <see cref="HdfVariable"/>.</param>
        /// <param name="length">Thee buffer length.</param>
        public DataStorageBase(HdfVariable HdfVariable, int length)
        {
            Contract.Requires(HdfVariable != null, nameof(HdfVariable));
            Contract.Requires(length >= 0, ErrorMessage.DataStorage_LengthNonNegative);

            this.HdfVariable = HdfVariable;
            this.Length = length;
            this.StatusSet1 = new bool[length];
            this.StatusSet2 = new bool[length];

            _gcHandle_Status1 = GCHandle.Alloc(StatusSet1, GCHandleType.Pinned);
            _gcHandle_Status2 = GCHandle.Alloc(StatusSet2, GCHandleType.Pinned);
        }

        #endregion

        #region "Properties"

        /// <summary>
        /// Gets the associated <see cref="HdfVariable"/>.
        /// </summary>
        /// <returns>Returns the associated <see cref="HdfVariable"/>.</returns>
        public HdfVariable HdfVariable { get; }

        /// <summary>
        /// Gets the buffer length.
        /// </summary>
        /// <returns>Returns the buffer length.</returns>
        public int Length { get; }

        /// <summary>
        /// Gets the status set of buffer 1.
        /// </summary>
        /// <returns>Returns the status set of buffer 1.</returns>
        public bool[] StatusSet1 { get; }

        /// <summary>
        /// Gets the status set of buffer 2.
        /// </summary>
        /// <returns>Returns the status set of buffer 2.</returns>
        public bool[] StatusSet2 { get; }

        #endregion

        #region "Methods"

        /// <summary>
        /// Gets an <see cref="IntPtr"/> for the status buffer.
        /// </summary>
        /// <param name="storage">The <see cref="StorageType"/>.</param>
        /// <returns>Returns an <see cref="IntPtr"/> for the status buffer.</returns>
        public IntPtr GetStatusIntPtr(StorageType storage)
        {
            switch (storage)
            {
                case StorageType.Storage1:
                    return _gcHandle_Status1.AddrOfPinnedObject();
                case StorageType.Storage2:
                    return _gcHandle_Status2.AddrOfPinnedObject();
                default:
                    throw new InvalidOperationException();
            }
        }

        public abstract object Read(int Index, StorageType storage);
        public abstract void Write(int Index, object Value, StorageType Storage);
        public abstract void Clear(StorageType Storage);
        public abstract IntPtr GetIntPtr(StorageType Storage);

        #endregion

        #region "IDisposable"

        private bool isDisposed;

        protected virtual void Dispose(bool isDisposing)
        {
            if (!isDisposed)
            {
                _gcHandle1.Free();
                _gcHandle2.Free();
                _gcHandle_Status1.Free();
                _gcHandle_Status2.Free();
            }

            isDisposed = true;
        }

        ~DataStorageBase()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}